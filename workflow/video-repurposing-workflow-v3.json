{
  "name": "Video Content Repurposing Pipeline v3",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "repurpose-video",
        "responseMode": "onReceived",
        "responseData": "allEntries",
        "options": {}
      },
      "id": "webhook-trigger",
      "name": "Webhook Trigger",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [0, 300],
      "webhookId": "video-repurpose-webhook"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "condition-jobId",
              "leftValue": "={{ $json.body.jobId }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "notEmpty"
              }
            },
            {
              "id": "condition-videoUrl",
              "leftValue": "={{ $json.body.videoUrl }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "notEmpty"
              }
            },
            {
              "id": "condition-callbackUrl",
              "leftValue": "={{ $json.body.callbackUrl }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "notEmpty"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "validate-input",
      "name": "Validate Input",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [220, 300]
    },
    {
      "parameters": {
        "values": {
          "string": [
            {
              "name": "error",
              "value": "Missing required fields: jobId, videoUrl, or callbackUrl"
            },
            {
              "name": "status",
              "value": "validation_error"
            }
          ]
        },
        "options": {}
      },
      "id": "validation-error",
      "name": "Validation Error",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [440, 500]
    },
    {
      "parameters": {
        "values": {
          "string": [
            {
              "name": "jobId",
              "value": "={{ $('Webhook Trigger').item.json.body.jobId }}"
            },
            {
              "name": "videoUrl",
              "value": "={{ $('Webhook Trigger').item.json.body.videoUrl }}"
            },
            {
              "name": "callbackUrl",
              "value": "={{ $('Webhook Trigger').item.json.body.callbackUrl }}"
            },
            {
              "name": "platform",
              "value": "={{ $('Webhook Trigger').item.json.body.platform || 'tiktok' }}"
            },
            {
              "name": "style",
              "value": "={{ $('Webhook Trigger').item.json.body.style || 'educational' }}"
            },
            {
              "name": "workDir",
              "value": "={{ '/data/' + $('Webhook Trigger').item.json.body.jobId }}"
            }
          ]
        },
        "options": {}
      },
      "id": "set-variables",
      "name": "Set Variables",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [440, 300]
    },
    {
      "parameters": {
        "jsCode": "const { execSync } = require('child_process');\n\nconst input = $input.first().json;\nconst webhookBody = $('Webhook Trigger').first().json.body;\n\nconst jobId = input.jobId || webhookBody.jobId;\nconst workDir = input.workDir || `/data/${jobId}`;\nconst videoUrl = input.videoUrl || webhookBody.videoUrl;\n\ntry {\n  // Create directory\n  execSync(`mkdir -p ${workDir}`);\n  \n  // Download video using yt-dlp\n  const command = `yt-dlp -f 'bestvideo[ext=mp4]+bestaudio[ext=m4a]/best[ext=mp4]/best' --merge-output-format mp4 -o '${workDir}/input.mp4' '${videoUrl}' 2>&1`;\n  \n  const result = execSync(command, {\n    encoding: 'utf8',\n    maxBuffer: 50 * 1024 * 1024,\n    timeout: 600000\n  });\n\n  return [{\n    json: {\n      ...input,\n      jobId,\n      workDir,\n      videoUrl,\n      downloadStatus: 'success',\n      downloadOutput: result\n    }\n  }];\n} catch (error) {\n  return [{\n    json: {\n      ...input,\n      jobId,\n      workDir,\n      videoUrl,\n      downloadStatus: 'failed',\n      downloadError: error.message,\n      downloadOutput: error.stdout || error.stderr || ''\n    }\n  }];\n}"
      },
      "id": "download-video",
      "name": "Download Video (yt-dlp)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [660, 300]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "check-download",
              "leftValue": "={{ $json.downloadStatus }}",
              "rightValue": "success",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-download",
      "name": "Check Download",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [880, 300]
    },
    {
      "parameters": {
        "jsCode": "const { execSync } = require('child_process');\nconst fs = require('fs');\n\nconst input = $input.first().json;\nconst webhookBody = $('Webhook Trigger').first().json.body;\n\nconst jobId = input.jobId || webhookBody.jobId;\nconst workDir = input.workDir || `/data/${jobId}`;\n\nif (!workDir || workDir === 'undefined') {\n  throw new Error('workDir is undefined. Cannot extract audio.');\n}\n\ntry {\n  const inputVideo = `${workDir}/input.mp4`;\n  const outputAudio = `${workDir}/audio.wav`;\n  \n  // Check if input video exists\n  if (!fs.existsSync(inputVideo)) {\n    throw new Error(`Input video file not found: ${inputVideo}`);\n  }\n  \n  const command = `ffmpeg -y -i \"${inputVideo}\" -vn -acodec pcm_s16le -ar 16000 -ac 1 \"${outputAudio}\" 2>&1`;\n  \n  try {\n    execSync(command, { \n      encoding: 'utf8',\n      maxBuffer: 50 * 1024 * 1024,\n      timeout: 300000\n    });\n  } catch (e) {\n    // FFmpeg writes to stderr even on success, but check if file was created\n    if (!fs.existsSync(outputAudio)) {\n      throw new Error(`FFmpeg failed: ${e.message}`);\n    }\n  }\n  \n  if (fs.existsSync(outputAudio)) {\n    return [{\n      json: {\n        ...input,\n        jobId,\n        workDir,\n        extractStatus: 'success'\n      }\n    }];\n  } else {\n    throw new Error('Audio file not created after FFmpeg execution');\n  }\n} catch (error) {\n  return [{\n    json: {\n      ...input,\n      jobId,\n      workDir,\n      extractStatus: 'failed',\n      extractError: error.message\n    }\n  }];\n}"
      },
      "id": "extract-audio",
      "name": "Extract Audio (FFmpeg)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1100, 300]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "check-extract",
              "leftValue": "={{ $json.extractStatus }}",
              "rightValue": "success",
              "operator": {
                "type": "string",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "check-extract",
      "name": "Check Extract",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [1320, 300]
    },
    {
      "parameters": {
        "jsCode": "const fs = require('fs');\nconst path = require('path');\n\nconst input = $input.first().json;\nconst webhookBody = $('Webhook Trigger').first().json.body;\n\nconst jobId = input.jobId || webhookBody.jobId;\nconst workDir = input.workDir || `/data/${jobId}`;\nconst audioPath = `${workDir}/audio.wav`;\n\ntry {\n  // Check if file exists\n  if (!fs.existsSync(audioPath)) {\n    throw new Error(`Audio file not found: ${audioPath}`);\n  }\n  \n  // Read file as binary\n  const audioBuffer = fs.readFileSync(audioPath);\n  \n  // Convert to base64 for n8n binary format\n  const base64Audio = audioBuffer.toString('base64');\n  \n  return [{\n    json: {\n      ...input,\n      jobId,\n      workDir\n    },\n    binary: {\n      data: {\n        data: base64Audio,\n        mimeType: 'audio/wav',\n        fileName: 'audio.wav'\n      }\n    }\n  }];\n} catch (error) {\n  throw new Error(`Failed to read audio file: ${error.message}`);\n}"
      },
      "id": "read-audio",
      "name": "Read Audio File",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1540, 300]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.openai.com/v1/audio/transcriptions",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "openAiApi",
        "sendBody": true,
        "contentType": "multipart-form-data",
        "bodyParameters": {
          "parameters": [
            {
              "name": "file",
              "parameterType": "formBinaryData",
              "inputDataFieldName": "data"
            },
            {
              "name": "model",
              "value": "whisper-1"
            },
            {
              "name": "response_format",
              "value": "verbose_json"
            },
            {
              "name": "timestamp_granularities[]",
              "value": "segment"
            }
          ]
        },
        "options": {
          "timeout": 300000
        }
      },
      "id": "transcribe-whisper",
      "name": "Transcribe (Whisper API)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1760, 300]
    },
    {
      "parameters": {
        "jsCode": "const segments = $input.first().json.segments || [];\nconst fullText = $input.first().json.text || '';\n\n// Get metadata from Set Variables node which has all the original webhook data\nconst setVars = $('Set Variables').first().json;\n\nconst platform = setVars.platform || 'tiktok';\nconst style = setVars.style || 'educational';\nconst jobId = setVars.jobId;\nconst workDir = setVars.workDir;\nconst callbackUrl = setVars.callbackUrl;\n\nconst userPrompt = `Your task is to identify the MOST ENGAGING moments from a video transcript that would perform well as standalone vertical clips on ${platform}.\n\nThe content style is: ${style}\n\nANALYZE THIS TRANSCRIPT:\n${fullText}\n\nTIMESTAMPED SEGMENTS:\n${JSON.stringify(segments)}\n\nRULES:\n1. Select EXACTLY 5 moments\n2. Each clip should be 30-60 seconds long\n3. Prioritize moments with:\n   - Strong hooks or surprising statements\n   - Emotional peaks or revelations\n   - Actionable advice or key insights\n   - Controversial or debate-worthy points\n   - Funny or relatable moments\n4. Ensure clips are self-contained and make sense without context\n5. Avoid mid-sentence cuts\n\nOUTPUT FORMAT (JSON only, no markdown):\n[\n  {\n    \"momentIndex\": 1,\n    \"start\": <start_time_in_seconds>,\n    \"end\": <end_time_in_seconds>,\n    \"reason\": \"<brief explanation why this moment is engaging>\",\n    \"hookPotential\": \"<the opening line that hooks viewers>\"\n  }\n]\n\nReturn ONLY the JSON array, no other text.`;\n\nconst requestBody = {\n  model: 'gpt-5.2',\n  messages: [\n    {\n      role: 'system',\n      content: 'You are an expert video content analyst for short-form social media. Return ONLY valid JSON, no markdown.'\n    },\n    {\n      role: 'user',\n      content: userPrompt\n    }\n  ],\n  temperature: 0.3,\n  max_completion_tokens: 2000\n};\n\nreturn [{\n  json: {\n    jobId: jobId,\n    workDir: workDir,\n    platform: platform,\n    style: style,\n    callbackUrl: callbackUrl,\n    transcript: JSON.stringify(segments),\n    fullText: fullText,\n    segmentCount: segments.length,\n    gptRequestBody: requestBody\n  }\n}];"
      },
      "id": "format-transcript",
      "name": "Format Transcript",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1980, 300]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.openai.com/v1/chat/completions",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "openAiApi",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify($json.gptRequestBody) }}",
        "options": {
          "timeout": 120000
        }
      },
      "id": "detect-moments",
      "name": "Detect Key Moments (GPT)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [2200, 300]
    },
    {
      "parameters": {
        "jsCode": "const response = $input.first().json;\nconst prevData = $('Format Transcript').first().json;\n\nlet gptContent = '';\nif (response.choices && response.choices[0] && response.choices[0].message) {\n  gptContent = response.choices[0].message.content;\n} else {\n  throw new Error('Invalid GPT response structure');\n}\n\nlet cleanedResponse = gptContent.replace(/```json\\n?/g, '').replace(/```\\n?/g, '').trim();\n\ntry {\n  const moments = JSON.parse(cleanedResponse);\n  \n  const validatedMoments = moments.map((m, idx) => ({\n    clipIndex: idx + 1,\n    start: parseFloat(m.start),\n    end: parseFloat(m.end),\n    duration: parseFloat(m.end) - parseFloat(m.start),\n    reason: m.reason,\n    hookPotential: m.hookPotential,\n    jobId: prevData.jobId,\n    workDir: prevData.workDir,\n    platform: prevData.platform,\n    style: prevData.style,\n    callbackUrl: prevData.callbackUrl,\n    fullText: prevData.fullText\n  }));\n  \n  return validatedMoments.map(m => ({ json: m }));\n} catch (e) {\n  throw new Error(`Failed to parse GPT response: ${e.message}. Response was: ${cleanedResponse}`);\n}"
      },
      "id": "parse-moments",
      "name": "Parse Moments",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2420, 300]
    },
    {
      "parameters": {
        "batchSize": 1,
        "options": {}
      },
      "id": "loop-moments",
      "name": "Loop Over Moments",
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [2640, 300]
    },
    {
      "parameters": {
        "jsCode": "const { execSync } = require('child_process');\nconst fs = require('fs');\n\nconst item = $input.first().json;\nconst workDir = item.workDir;\nconst clipIndex = item.clipIndex;\nconst start = item.start;\nconst duration = item.duration;\n\ntry {\n  const probeWidth = execSync(`ffprobe -v error -select_streams v:0 -show_entries stream=width -of csv=p=0 \"${workDir}/input.mp4\"`, { encoding: 'utf8' }).trim();\n  const probeHeight = execSync(`ffprobe -v error -select_streams v:0 -show_entries stream=height -of csv=p=0 \"${workDir}/input.mp4\"`, { encoding: 'utf8' }).trim();\n  \n  const width = parseInt(probeWidth);\n  const height = parseInt(probeHeight);\n  const targetRatio = 9 / 16;\n  \n  let cropW, cropH;\n  if (width / height > targetRatio) {\n    cropH = height;\n    cropW = Math.floor(height * targetRatio);\n  } else {\n    cropW = width;\n    cropH = Math.floor(width / targetRatio);\n  }\n  \n  const outputPath = `${workDir}/clip_${clipIndex}.mp4`;\n  \n  const ffmpegCmd = `ffmpeg -y -ss ${start} -i \"${workDir}/input.mp4\" -t ${duration} -vf \"crop=${cropW}:${cropH}:(in_w-${cropW})/2:(in_h-${cropH})/2,scale=1080:1920:force_original_aspect_ratio=decrease,pad=1080:1920:(ow-iw)/2:(oh-ih)/2\" -c:v libx264 -preset fast -crf 23 -c:a aac -b:a 128k -movflags +faststart \"${outputPath}\" 2>&1`;\n  \n  try {\n    execSync(ffmpegCmd, { \n      encoding: 'utf8',\n      maxBuffer: 50 * 1024 * 1024,\n      timeout: 300000\n    });\n  } catch (e) {\n    // FFmpeg may write to stderr\n  }\n  \n  if (fs.existsSync(outputPath)) {\n    return [{\n      json: {\n        ...item,\n        clipPath: outputPath,\n        clipStatus: 'success'\n      }\n    }];\n  } else {\n    throw new Error('Output file not created');\n  }\n} catch (error) {\n  return [{\n    json: {\n      ...item,\n      clipStatus: 'failed',\n      clipError: error.message\n    }\n  }];\n}"
      },
      "id": "cut-clip",
      "name": "Cut Clip (FFmpeg)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2860, 300]
    },
    {
      "parameters": {
        "jsCode": "const item = $input.first().json;\n\nconst userPrompt = `GENERATE CAPTION FOR THIS CLIP:\n\nClip Context: ${item.reason || ''}\nHook Moment: ${item.hookPotential || ''}\nContent Style: ${item.style || 'educational'}\nPlatform: ${item.platform || 'tiktok'}\n\nCREATE:\n1. HOOK: The first line viewers see (max 10 words, must stop the scroll)\n2. CAPTION: 1-2 short lines that add context or create curiosity (casual ${item.platform || 'tiktok'} tone)\n3. HASHTAGS: Exactly 5 relevant hashtags (mix of broad + niche)\n\nPLATFORM GUIDELINES:\n- TikTok: Casual, trendy, use slang appropriately, emojis welcome\n- Instagram: Slightly more polished, storytelling elements\n- YouTube Shorts: Value-focused, clear benefit statement\n\nOUTPUT FORMAT (JSON only):\n{\n  \"hook\": \"<scroll-stopping first line>\",\n  \"caption\": \"<1-2 line caption>\",\n  \"hashtags\": [\"#tag1\", \"#tag2\", \"#tag3\", \"#tag4\", \"#tag5\"]\n}\n\nReturn ONLY the JSON object, no other text.`;\n\nconst requestBody = {\n  model: 'gpt-5.2',\n  messages: [\n    {\n      role: 'system',\n      content: 'You are a viral social media copywriter. Return ONLY valid JSON, no markdown.'\n    },\n    {\n      role: 'user',\n      content: userPrompt\n    }\n  ],\n  temperature: 0.7,\n  max_completion_tokens: 500\n};\n\nreturn [{\n  json: {\n    ...item,\n    captionRequestBody: requestBody\n  }\n}];"
      },
      "id": "prepare-caption-request",
      "name": "Prepare Caption Request",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [3080, 300]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.openai.com/v1/chat/completions",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "openAiApi",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify($json.captionRequestBody) }}",
        "options": {
          "timeout": 60000
        }
      },
      "id": "generate-caption",
      "name": "Generate Caption (GPT)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [3190, 300]
    },
    {
      "parameters": {
        "jsCode": "const response = $input.first().json;\nconst previousData = $('Prepare Caption Request').first().json;\n\nlet gptContent = '';\nif (response.choices && response.choices[0] && response.choices[0].message) {\n  gptContent = response.choices[0].message.content;\n} else {\n  gptContent = '{\"hook\": \"You need to see this\", \"caption\": \"Watch till the end!\", \"hashtags\": [\"#viral\", \"#foryou\", \"#trending\", \"#mustwatch\", \"#fyp\"]}';\n}\n\nlet cleanedResponse = gptContent.replace(/```json\\n?/g, '').replace(/```\\n?/g, '').trim();\n\ntry {\n  const caption = JSON.parse(cleanedResponse);\n  \n  return [{\n    json: {\n      clipIndex: previousData.clipIndex,\n      clipPath: previousData.clipPath,\n      hook: caption.hook,\n      caption: caption.caption,\n      hashtags: caption.hashtags,\n      jobId: previousData.jobId,\n      workDir: previousData.workDir,\n      callbackUrl: previousData.callbackUrl,\n      platform: previousData.platform,\n      reason: previousData.reason\n    }\n  }];\n} catch (e) {\n  return [{\n    json: {\n      clipIndex: previousData.clipIndex,\n      clipPath: previousData.clipPath,\n      hook: previousData.hookPotential || \"You need to see this\",\n      caption: \"Watch till the end!\",\n      hashtags: [\"#viral\", \"#foryou\", \"#trending\", \"#mustwatch\", \"#fyp\"],\n      jobId: previousData.jobId,\n      workDir: previousData.workDir,\n      callbackUrl: previousData.callbackUrl,\n      platform: previousData.platform,\n      reason: previousData.reason\n    }\n  }];\n}"
      },
      "id": "parse-caption",
      "name": "Parse Caption",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [3300, 300]
    },
    {
      "parameters": {
        "jsCode": "const fs = require('fs');\n\nconst input = $input.first().json;\nconst clipPath = input.clipPath;\nconst clipIndex = input.clipIndex;\n\ntry {\n  // Check if file exists\n  if (!clipPath || !fs.existsSync(clipPath)) {\n    throw new Error(`Clip file not found: ${clipPath}`);\n  }\n  \n  // Read file as binary\n  const clipBuffer = fs.readFileSync(clipPath);\n  \n  // Convert to base64 for n8n binary format\n  const base64Clip = clipBuffer.toString('base64');\n  \n  return [{\n    json: {\n      ...input\n    },\n    binary: {\n      data: {\n        data: base64Clip,\n        mimeType: 'video/mp4',\n        fileName: `clip_${clipIndex}.mp4`\n      }\n    }\n  }];\n} catch (error) {\n  throw new Error(`Failed to read clip file: ${error.message}`);\n}"
      },
      "id": "read-clip",
      "name": "Read Clip File",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [3520, 300]
    },
    {
      "parameters": {
        "jsCode": "const prevData = $('Parse Caption').first().json;\nconst binaryData = $input.first().binary.data;\n\n// R2 Configuration from environment\nconst accountId = process.env.R2_ACCOUNT_ID || '';\nconst bucketName = process.env.R2_BUCKET_NAME || '';\n\nif (!accountId || !bucketName) {\n  throw new Error('R2_ACCOUNT_ID and R2_BUCKET_NAME must be set in environment variables');\n}\n\n// Ensure callbackUrl is available - get from Set Variables if not in current data\nlet callbackUrl = prevData.callbackUrl;\nif (!callbackUrl) {\n  try {\n    callbackUrl = $('Set Variables').first().json.callbackUrl;\n  } catch (e) {\n    callbackUrl = '';\n  }\n}\n\nconst objectKey = `clips/${prevData.jobId}/clip_${prevData.clipIndex}.mp4`;\nconst uploadUrl = `https://${accountId}.r2.cloudflarestorage.com/${bucketName}/${objectKey}`;\nconst publicUrl = `https://pub-${accountId}.r2.dev/${objectKey}`;\n\nreturn [{\n  json: {\n    clipIndex: prevData.clipIndex,\n    clipPath: prevData.clipPath,\n    uploadUrl: uploadUrl,\n    url: publicUrl,\n    hook: prevData.hook,\n    caption: prevData.caption,\n    hashtags: prevData.hashtags,\n    jobId: prevData.jobId,\n    workDir: prevData.workDir,\n    callbackUrl: callbackUrl,\n    platform: prevData.platform,\n    uploadStatus: 'pending'\n  },\n  binary: {\n    data: binaryData\n  }\n}];"
      },
      "id": "prepare-upload",
      "name": "Prepare Upload",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [3740, 300]
    },
    {
      "parameters": {
        "method": "PUT",
        "url": "={{ $json.uploadUrl }}",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "aws",
        "sendBody": true,
        "contentType": "binaryData",
        "inputDataFieldName": "=data",
        "options": {
          "response": {
            "response": {
              "neverError": true
            }
          }
        }
      },
      "id": "upload-r2",
      "name": "Upload to R2",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [3960, 300]
    },
    {
      "parameters": {
        "jsCode": "const prevData = $('Prepare Upload').first().json;\nconst fs = require('fs');\nconst workDir = prevData.workDir;\n\nif (!workDir || workDir === 'undefined') {\n  throw new Error('workDir is undefined in Format Clip Result');\n}\n\n// Ensure callbackUrl is available from previous data\nlet callbackUrl = prevData.callbackUrl;\nlet jobId = prevData.jobId;\n\nif (!callbackUrl) {\n  throw new Error('callbackUrl is missing in Format Clip Result. prevData keys: ' + Object.keys(prevData).join(', '));\n}\n\nconst clipData = {\n  clipIndex: prevData.clipIndex,\n  url: prevData.url,\n  hook: prevData.hook,\n  caption: prevData.caption,\n  hashtags: prevData.hashtags\n};\n\n// Store clip data AND metadata to a file\nconst clipsFile = `${workDir}/clips.json`;\nlet fileData = {\n  jobId: jobId,\n  callbackUrl: callbackUrl,\n  clips: []\n};\n\ntry {\n  if (fs.existsSync(clipsFile)) {\n    const content = fs.readFileSync(clipsFile, 'utf8');\n    fileData = JSON.parse(content);\n  }\n} catch (e) {\n  // File doesn't exist yet or is invalid, start fresh\n  fileData = {\n    jobId: jobId,\n    callbackUrl: callbackUrl,\n    clips: []\n  };\n}\n\nfileData.clips.push(clipData);\n\ntry {\n  fs.writeFileSync(clipsFile, JSON.stringify(fileData, null, 2));\n} catch (e) {\n  throw new Error(`Failed to write clips file to ${clipsFile}: ${e.message}`);\n}\n\nreturn [{\n  json: clipData\n}];"
      },
      "id": "format-result",
      "name": "Format Clip Result",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [4180, 300]
    },
    {
      "parameters": {
        "aggregate": "aggregateAllItemData",
        "destinationFieldName": "clips",
        "options": {}
      },
      "id": "aggregate-clips",
      "name": "Aggregate Clips",
      "type": "n8n-nodes-base.aggregate",
      "typeVersion": 1,
      "position": [4400, 300]
    },
    {
      "parameters": {
        "jsCode": "const fs = require('fs');\nconst path = require('path');\n\n// Get aggregated data\nconst aggregatedData = $input.first().json;\nconst rawClips = aggregatedData.clips || [];\n\nif (rawClips.length === 0) {\n  throw new Error('No clips in aggregated data');\n}\n\nconst firstClip = rawClips[0];\nconst jobId = firstClip.jobId;\nconst workDir = `/data/${jobId}`;\nconst clipsFile = `${workDir}/clips.json`;\n\n// Get callbackUrl from webhook - it's always available there\nlet callbackUrl;\ntry {\n  callbackUrl = $('Webhook Trigger').first().json.body.callbackUrl;\n} catch (e) {\n  throw new Error('Cannot access Webhook Trigger data');\n}\n\nif (!callbackUrl) {\n  throw new Error('callbackUrl not found in webhook data');\n}\n\n// Try to read clips.json if it exists, otherwise build from aggregated data\nlet clips = [];\n\nif (fs.existsSync(clipsFile)) {\n  try {\n    const fileContent = fs.readFileSync(clipsFile, 'utf8');\n    const fileData = JSON.parse(fileContent);\n    clips = fileData.clips || [];\n  } catch (e) {\n    // File exists but can't be read, will use empty array\n  }\n}\n\n// If no clips in file, the loop didn't complete successfully\n// Send a callback anyway with the status\nif (clips.length === 0) {\n  // Loop didn't produce any formatted clips\n  // This could mean GPT didn't detect moments or the loop failed\n  const payload = {\n    jobId: jobId,\n    status: 'completed_with_errors',\n    processedAt: new Date().toISOString(),\n    clipCount: 0,\n    message: 'Workflow completed but no clips were formatted. Check if GPT detected moments and if the clip processing loop executed.',\n    clips: []\n  };\n  \n  return [{\n    json: {\n      callbackUrl: callbackUrl,\n      payload: payload\n    }\n  }];\n}\n\nconst payload = {\n  jobId: jobId,\n  status: 'success',\n  processedAt: new Date().toISOString(),\n  clipCount: clips.length,\n  clips: clips\n};\n\nreturn [{\n  json: {\n    callbackUrl: callbackUrl,\n    payload: payload\n  }\n}];"
      },
      "id": "prepare-callback",
      "name": "Prepare Callback",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [4620, 300]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $json.callbackUrl && $json.callbackUrl.trim() !== '' ? $json.callbackUrl : 'https://httpbin.org/post' }}",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify($json.payload) }}",
        "options": {
          "timeout": 30000,
          "response": {
            "response": {
              "neverError": true,
              "fullResponse": false
            }
          },
          "redirect": {
            "redirect": {
              "followRedirects": true
            }
          }
        }
      },
      "id": "send-callback",
      "name": "Send Success Callback",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [4840, 300]
    },
    {
      "parameters": {
        "jsCode": "const { execSync } = require('child_process');\n\ntry {\n  const workDir = $('Set Variables').first().json.workDir;\n  execSync(`rm -rf ${workDir}`);\n  return [{ json: { cleanup: 'success' } }];\n} catch (error) {\n  return [{ json: { cleanup: 'failed', error: error.message } }];\n}"
      },
      "id": "cleanup",
      "name": "Cleanup Files",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [5060, 300]
    },
    {
      "parameters": {
        "jsCode": "const errorData = $input.first().json;\nlet setVars = {};\ntry {\n  setVars = $('Set Variables').first()?.json || {};\n} catch(e) {}\n\n// Fallback: If Set Variables didn't run, try to get callbackUrl from Webhook body\nlet callbackUrl = setVars?.callbackUrl;\nif (!callbackUrl) {\n  try {\n    callbackUrl = $('Webhook Trigger').first().json.body.callbackUrl;\n  } catch (e) {\n    callbackUrl = '';\n  }\n}\n\nconst payload = {\n  jobId: setVars?.jobId || $('Webhook Trigger').first().json.body?.jobId || 'unknown',\n  status: 'failed',\n  failedAt: new Date().toISOString(),\n  error: {\n    stage: errorData.errorStage || 'unknown',\n    message: errorData.errorMessage || errorData.downloadError || errorData.extractError || 'Unknown error occurred',\n    details: null\n  }\n};\n\nreturn [{\n  json: {\n    callbackUrl: callbackUrl || '',\n    payload: payload\n  }\n}];"
      },
      "id": "prepare-error-callback",
      "name": "Prepare Error Callback",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1100, 600]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "={{ $json.callbackUrl }}",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify($json.payload) }}",
        "options": {
          "timeout": 30000,
          "response": {
            "response": {
              "neverError": true
            }
          }
        }
      },
      "id": "send-error-callback",
      "name": "Send Error Callback",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1320, 600]
    },
    {
      "parameters": {
        "values": {
          "string": [
            {
              "name": "errorStage",
              "value": "download"
            },
            {
              "name": "errorMessage",
              "value": "={{ $json.downloadError || 'Video download failed' }}"
            }
          ]
        },
        "options": {}
      },
      "id": "download-error",
      "name": "Download Error",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [880, 500]
    },
    {
      "parameters": {
        "values": {
          "string": [
            {
              "name": "errorStage",
              "value": "audio_extraction"
            },
            {
              "name": "errorMessage",
              "value": "={{ $json.extractError || 'Audio extraction failed' }}"
            }
          ]
        },
        "options": {}
      },
      "id": "extract-error",
      "name": "Extract Error",
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [1320, 500]
    }
  ],
  "connections": {
    "Webhook Trigger": {
      "main": [
        [
          {
            "node": "Validate Input",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate Input": {
      "main": [
        [
          {
            "node": "Set Variables",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Validation Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validation Error": {
      "main": [
        [
          {
            "node": "Prepare Error Callback",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set Variables": {
      "main": [
        [
          {
            "node": "Download Video (yt-dlp)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Download Video (yt-dlp)": {
      "main": [
        [
          {
            "node": "Check Download",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Download": {
      "main": [
        [
          {
            "node": "Extract Audio (FFmpeg)",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Download Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Download Error": {
      "main": [
        [
          {
            "node": "Prepare Error Callback",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Audio (FFmpeg)": {
      "main": [
        [
          {
            "node": "Check Extract",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Extract": {
      "main": [
        [
          {
            "node": "Read Audio File",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Extract Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Error": {
      "main": [
        [
          {
            "node": "Prepare Error Callback",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Read Audio File": {
      "main": [
        [
          {
            "node": "Transcribe (Whisper API)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Transcribe (Whisper API)": {
      "main": [
        [
          {
            "node": "Format Transcript",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Transcript": {
      "main": [
        [
          {
            "node": "Detect Key Moments (GPT)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Detect Key Moments (GPT)": {
      "main": [
        [
          {
            "node": "Parse Moments",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Moments": {
      "main": [
        [
          {
            "node": "Loop Over Moments",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Loop Over Moments": {
      "main": [
        [
          {
            "node": "Cut Clip (FFmpeg)",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Aggregate Clips",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Cut Clip (FFmpeg)": {
      "main": [
        [
          {
            "node": "Prepare Caption Request",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Caption Request": {
      "main": [
        [
          {
            "node": "Generate Caption (GPT)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Generate Caption (GPT)": {
      "main": [
        [
          {
            "node": "Parse Caption",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Caption": {
      "main": [
        [
          {
            "node": "Read Clip File",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Read Clip File": {
      "main": [
        [
          {
            "node": "Prepare Upload",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Upload": {
      "main": [
        [
          {
            "node": "Upload to R2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Upload to R2": {
      "main": [
        [
          {
            "node": "Format Clip Result",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Format Clip Result": {
      "main": [
        [
          {
            "node": "Loop Over Moments",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Aggregate Clips": {
      "main": [
        [
          {
            "node": "Prepare Callback",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Callback": {
      "main": [
        [
          {
            "node": "Send Success Callback",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send Success Callback": {
      "main": [
        [
          {
            "node": "Cleanup Files",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prepare Error Callback": {
      "main": [
        [
          {
            "node": "Send Error Callback",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "saveExecutionProgress": true,
    "saveManualExecutions": true,
    "callerPolicy": "workflowsFromSameOwner"
  },
  "staticData": null,
  "tags": [
    {
      "name": "video-processing"
    },
    {
      "name": "automation"
    }
  ],
  "triggerCount": 1,
  "versionId": "3"
}

